from typing import TypeVar, Optional, Callable, cast

import numpy as np

NDArray1 = TypeVar('NDArray1', bound=np.ndarray)
NDArray2 = TypeVar('NDArray2', bound=np.ndarray)
F = TypeVar('F', bound=Callable)


def split_uniformly(
    data: NDArray1,
    labels: NDArray2,
    client_num: int,
    *,
    shuffle: bool = True,
    stratify: Optional[np.ndarray] = None
) -> list[tuple[NDArray1, NDArray2]]:
    """
    Split data and labels into clients uniformly.

    :param data: shape(N, ...)
    :param labels: shape(N, )
    :param client_num: number of clients.
    :param shuffle: Whether or not to shuffle the data before splitting.
        If shuffle=False then stratify must be None.
    :param stratified: If not None, data is split in a stratified fashion,
        using this as the class labels.
    :return: List of (data, labels).
    """
    ratios = np.repeat(1 / client_num, client_num)
    return _split_by_client_ratios(data, labels, ratios, shuffle=shuffle, stratify=stratify)


def split_dirichlet_quantity(
    data: NDArray1,
    labels: NDArray2,
    client_num: int,
    *,
    alpha: float,
    shuffle: bool = True,
    stratify: Optional[np.ndarray] = None
) -> list[tuple[NDArray1, NDArray2]]:
    """
    Split data and labels into clients. The number of samples per client
    is generated by Dirichlet distributions.

    :param data: shape(N, ...)
    :param labels: shape(N, )
    :param client_num: number of clients.
    :param alpha: parameter of Dirichlet distribution.
    :param shuffle: Whether or not to shuffle the data before splitting.
        If shuffle=False then stratify must be None.
    :param stratified: If not None, data is split in a stratified fashion,
        using this as the class labels.
    :return: List of (data, labels).
    """
    ratios = np.random.dirichlet(np.repeat(alpha, client_num))  # shape(client_num,)
    return _split_by_client_ratios(data, labels, ratios, shuffle=shuffle, stratify=stratify)


def _split_by_client_ratios(
    data: NDArray1,
    labels: NDArray2,
    ratios: np.ndarray,
    *,
    shuffle: bool = True,
    stratify: Optional[np.ndarray] = None
) -> list[tuple[NDArray1, NDArray2]]:
    if stratify is not None and not shuffle:
        raise ValueError('If shuffle=False then stratify must be None.')
    indices = np.arange(len(data))
    if stratify is None:
        if shuffle:
            np.random.shuffle(indices)
        clients_indices = _array_split_by_ratios(indices, ratios)
    else:
        class_num = len(np.unique(labels))
        proportion = np.stack([ratios for _ in range(class_num)])
        clients_indices = [x for x, _ in _convert_labels(_split_by_proportion)(indices, stratify, proportion)]
    return [(data[indices], labels[indices]) for indices in clients_indices]


def _map_labels_to_continuous(labels: NDArray2, indexer: np.ndarray) -> NDArray2:
    """Label of `indexer[i]` will be mapped to `i`."""
    mapping = {label: i for i, label in enumerate(indexer)}
    return np.array([mapping[label] for label in labels], dtype=labels.dtype)


def _recover_labels(labels: NDArray2, indexer: np.ndarray) -> NDArray2:
    """Label `i` will be mapped to `indexer[i]`."""
    return np.array([indexer[label] for label in labels], dtype=labels.dtype)


def _convert_labels(f: F) -> F:
    def wrapper(data, labels, *args, **kwargs):
        classes = np.unique(labels)
        labels = _map_labels_to_continuous(labels, classes)
        results = f(data, labels, *args, **kwargs)
        return [(x, _recover_labels(y, classes)) for x, y in results]

    return cast(F, wrapper)


@_convert_labels
def split_dirichlet_label(
    data: NDArray1,
    labels: NDArray2,
    client_num: int,
    *,
    alpha: float,
) -> list[tuple[NDArray1, NDArray2]]:
    """
    Split data and labels into clients. The distribution of each class
    is generated by Dirichlet distributions.

    :param data: shape(N, ...)
    :param labels: shape(N, )
    :param client_num: number of clients.
    :param alpha: parameter of Dirichlet distribution.
    :return: List of (data, labels).
    """
    class_num = len(np.unique(labels))
    proportion = np.random.dirichlet(
        alpha=np.repeat(alpha, client_num),
        size=class_num
    )  # shape(class_num, client_num), sum by row is 1
    return _split_by_proportion(data, labels, proportion)


@_convert_labels
def split_by_label(
    data: NDArray1,
    labels: NDArray2,
    client_num: int,
    *,
    class_per_client: int
) -> list[tuple[NDArray1, NDArray2]]:
    """
    Split data and labels into clients. Each client has `class_per_client` classes.

    :param data: shape(N, ...)
    :param labels: shape(N, )
    :param client_num: number of clients.
    :param class_per_client: each client has `class_per_client` classes.
    :return: List of (data, labels).
    """
    classes = np.unique(labels)
    class_num = len(classes)
    if class_per_client > class_num:
        raise ValueError("'class_per_client' should be less than or equal to 'class_num'")
    if client_num * class_per_client < class_num:
        raise ValueError('Each class should be assigned to at least one client.')
    # ensure that len(classes_sequence) >= client_num * class_per_client
    repeat_count = _ceil_div(client_num * class_per_client, class_num)

    classes_sequence = []
    for _ in range(repeat_count):
        np.random.shuffle(classes)
        classes_sequence.extend(classes.tolist())
    classes_sequence = np.array(classes_sequence)

    clients_classes = [
        classes_sequence[i:(i + class_per_client)]
        for i in range(0, client_num * class_per_client, class_per_client)
    ]
    proportion = np.zeros((class_num, client_num))
    for client in range(client_num):
        for c in clients_classes[client]:
            proportion[c, client] = 1
    return _split_by_proportion(data, labels, proportion)


def _ceil_div(a: int, b: int) -> int:
    """Ensure that `ceil_div(a, b) * b >= a`"""
    return (a + b - 1) // b


def _split_by_proportion(
    data: NDArray1,
    labels: NDArray2,
    proportion: np.ndarray
) -> list[tuple[NDArray1, NDArray2]]:
    """
    :param data: shape(N, ...)
    :param labels: shape(N, ), label must be continuous and start from zero.
    :param proportion: shape(class_num, client_num). Row i is class i's client proportion.
    :return: List of (data, labels).
    """
    class_num, client_num = proportion.shape
    assert labels.min() == 0 and labels.max() == class_num - 1
    classes_indices: list[list[int]] = [[] for _ in range(class_num)]
    for i, c in enumerate(labels):
        classes_indices[c].append(i)
    clients_indices: list[list[int]] = [[] for _ in range(client_num)]
    for c in range(class_num):
        class_indices = np.array(classes_indices[c])
        np.random.shuffle(class_indices)
        for client, indices in enumerate(_array_split_by_ratios(class_indices, proportion[c])):
            clients_indices[client].extend(indices)
    return [(data[indices], labels[indices]) for indices in clients_indices]


def _array_split_by_ratios(array: NDArray1, ratios: np.ndarray) -> list[NDArray1]:
    "`ratios` will be normalized automatically."
    counts = _counts_from_ratios(len(array), ratios)
    split_points = np.cumsum(counts)[:-1]
    return np.array_split(array, split_points)


def _counts_from_ratios(total: int, ratios: np.ndarray) -> np.ndarray:
    ratios = ratios / ratios.sum()
    counts = total * ratios
    result = np.floor(counts).astype(np.int64)
    rest = total - result.sum()
    if rest > 0:
        result[np.argsort(counts - result)[-rest:]] += 1
    return result
